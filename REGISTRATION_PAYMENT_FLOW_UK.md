# Документація з процесу реєстрації, оплати та промокодів

## Огляд

Цей документ описує повний процес реєстрації на події, обробки платежів та інтеграції промокодів у додатку. Він охоплює моделі даних, правила валідації, переходи станів та взаємодію між усіма трьома системами.

## Зміст

1. [Архітектура системи](#архітектура-системи)
2. [Моделі даних](#моделі-даних)
3. [Процес реєстрації](#процес-реєстрації)
4. [Процес оплати](#процес-оплати)
5. [Інтеграція промокодів](#інтеграція-промокодів)
6. [Повний процес від початку до кінця](#повний-процес-від-початку-до-кінця)
7. [Правила валідації](#правила-валідації)
8. [Переходи станів](#переходи-станів)
9. [Безпека транзакцій](#безпека-транзакцій)
10. [Обробка помилок](#обробка-помилок)
11. [API ендпоінти](#api-ендпоінти)

---

## Архітектура системи

Система складається з трьох основних компонентів, які працюють разом:

```
┌─────────────┐
│ Registration│
└──────┬──────┘
       │
       ├───► Promo Code (optional)
       │
       └───► Payment
             │
             └───► Monobank (Payment Gateway)
```

### Взаємозв'язки компонентів

- **Registration (Реєстрація)**: Основна сутність, яка відстежує інформацію про учасника та його статус
- **Payment (Оплата)**: Пов'язана з реєстрацією, відстежує статус оплати та інтеграцію з платіжним шлюзом
- **Promo Code (Промокод)**: Опціональна знижка, застосовується під час реєстрації, використання відстежується після оплати

---

## Моделі даних

### Модель реєстрації

**Файл**: `src/models/Registration.ts`

```typescript
interface IRegistration {
  _id: ObjectId;
  eventId: ObjectId; // Обов'язково: Посилання на подію
  userId?: ObjectId; // Опціонально: Для автентифікованих користувачів
  name?: string; // Обов'язково для публічної реєстрації
  surname?: string; // Обов'язково для публічної реєстрації
  email?: string; // Обов'язково для публічної реєстрації
  city?: string; // Обов'язково для публічної реєстрації
  runningClub?: string; // Опціонально
  phone?: string; // Опціонально
  promoCode?: string; // Опціонально: Рядок коду (великі літери)
  promoCodeId?: ObjectId; // Опціонально: Посилання на PromoCode
  status: 'pending' | 'confirmed' | 'cancelled';
  registeredAt: Date;
  paymentStatus: 'pending' | 'completed' | 'failed';
  paymentId?: string; // Посилання на Payment._id
  finalPrice?: number; // Ціна після знижки промокоду
  createdAt: Date;
  updatedAt: Date;
}
```

**Ключові обмеження**:

- Унікальне обмеження: `(eventId, userId)` для автентифікованих користувачів
- Унікальне обмеження: `(eventId, email)` для публічних реєстрацій
- `finalPrice` має бути >= 0

**Індекси**:

- `{ eventId: 1, userId: 1 }` (унікальний, частковий)
- `{ eventId: 1, email: 1 }` (унікальний, частковий)
- `{ eventId: 1 }`
- `{ userId: 1 }`
- `{ status: 1 }`
- `{ paymentStatus: 1 }`
- `{ promoCodeId: 1 }`

### Модель оплати

**Файл**: `src/models/Payment.ts`

```typescript
interface IPayment {
  _id: ObjectId;
  registrationId: ObjectId; // Обов'язково: Посилання на Registration
  amount: number; // Обов'язково: Сума оплати (>= 0)
  currency: string; // За замовчуванням: 'UAH'
  status: 'pending' | 'completed' | 'failed' | 'refunded';
  plataMonoInvoiceId?: string; // ID рахунку Monobank
  plataMonoPaymentId?: string; // ID платежу Monobank
  paymentLink?: string; // URL для завершення оплати користувачем
  webhookData?: Record<string, unknown>; // Сирі дані webhook
  createdAt: Date;
  updatedAt: Date;
}
```

**Ключові обмеження**:

- `amount` має бути >= 0
- `currency` за замовчуванням 'UAH'

**Індекси**:

- `{ registrationId: 1 }`
- `{ plataMonoInvoiceId: 1 }`
- `{ status: 1 }`

### Модель промокоду

**Файл**: `src/models/PromoCode.ts`

```typescript
interface IPromoCode {
  _id: ObjectId;
  code: string; // Обов'язково: Унікальний, великі літери, макс 50 символів
  discountType: 'percentage' | 'amount';
  discountValue: number; // Обов'язково: > 0
  usageLimit: number; // Обов'язково: >= 1
  usedCount: number; // За замовчуванням: 0, >= 0
  isActive: boolean; // За замовчуванням: true
  expirationDate?: Date; // Опціональна дата закінчення
  eventId?: ObjectId; // Опціонально: Код для конкретної події
  createdAt: Date;
  updatedAt: Date;
}
```

**Ключові обмеження**:

- `code` має бути унікальним
- `discountValue` має бути > 0
- `usageLimit` має бути >= 1
- `usedCount` має бути >= 0

**Індекси**:

- `{ code: 1 }` (унікальний)
- `{ isActive: 1 }`
- `{ eventId: 1 }`

---

## Процес реєстрації

### Публічна реєстрація (без автентифікації)

**Ендпоінт**: `POST /api/registrations`

**Кроки процесу**:

1. **Валідація вхідних даних**
   - Валідація обов'язкових полів: `eventId`, `name`, `surname`, `email`, `city`
   - Валідація опціональних полів: `runningClub`, `phone`, `promoCode`
   - Валідація формату email
   - Валідація формату телефону (якщо надано)

2. **Валідація події**
   - Розв'язання ID події (підтримує UUID або ObjectId, fallback до налаштованої єдиної події)
   - Перевірка існування події
   - Перевірка наявності вільних місць (`registeredCount < capacity`)
   - Дата події має бути в майбутньому (перевіряється при створенні події)

3. **Запобігання дублюванню**
   - Перевірка, чи email вже зареєстрований на цю подію
   - Якщо знайдено дублікат, викидається `ConflictError`

4. **Обробка промокоду** (якщо надано)
   - Нормалізація коду (великі літери, обрізання пробілів)
   - Валідація промокоду (див. [Валідація промокоду](#валідація-промокоду))
   - Розрахунок фінальної ціни за допомогою утиліти `calculatePrice()`

5. **Розрахунок ціни**
   - Отримання базової ціни з події (`event.basePrice`) або конфігурації (`eventConfig.basePrice`)
   - Якщо базова ціна не налаштована, викидається `ConflictError`
   - Застосування знижки промокоду, якщо він валідний
   - Збереження `finalPrice` в реєстрації

6. **Створення реєстрації** (в межах транзакції)
   - Створення реєстрації зі статусом `'pending'`
   - Встановлення `paymentStatus` на `'pending'`
   - Збереження рядка промокоду та посилання (якщо застосовно)

7. **Створення оплати** (в межах тієї ж транзакції)
   - Створення запису про оплату зі статусом `'pending'`
   - Виклик API Monobank для створення рахунку
   - Збереження `plataMonoInvoiceId` та `paymentLink`
   - Зв'язування оплати з реєстрацією через `paymentId`

8. **Підтвердження транзакції**
   - Всі операції з базою даних успішні або невдалі разом
   - Повернення реєстрації та посилання на оплату

**Відповідь**:

```json
{
  "success": true,
  "data": {
    "registration": {
      "id": "...",
      "eventId": "...",
      "name": "Іван",
      "surname": "Петренко",
      "email": "ivan@example.com",
      "city": "Київ",
      "promoCode": "DISCOUNT10",
      "finalPrice": 900,
      "status": "pending",
      "paymentStatus": "pending"
    },
    "paymentLink": "https://pay.monobank.ua/..."
  }
}
```

### Автентифікована реєстрація

**Ендпоінт**: `POST /api/registrations` (з токеном автентифікації)

**Відмінності від публічної реєстрації**:

- Використовує `userId` з автентифікованого користувача
- Не потрібні `name`, `surname`, `email`, `city` (можуть бути отримані з профілю користувача)
- Все ще підтримує промокоди
- Статус реєстрації починається як `'confirmed'` (негайне підтвердження)
- Статус оплати починається як `'completed'` (вважається оплаченим)
- `registeredCount` події збільшується негайно

---

## Процес оплати

### Створення оплати

**Запускається під час**: Створення реєстрації

**Процес**:

1. **Створення запису про оплату**
   - Сума: `finalPrice` з реєстрації
   - Валюта: З конфігурації (за замовчуванням: 'UAH')
   - Статус: `'pending'`
   - Зв'язано з реєстрацією через `registrationId`

2. **Створення рахунку Monobank**
   - API Ендпоінт: `https://api.monobank.ua/api/merchant/invoice/create`
   - Метод: `POST`
   - Заголовки: `X-Token: {plataApiKey}`
   - Документація: [Monobank API Docs](https://monobank.ua/api-docs/acquiring/methods/ia/post--api--merchant--invoice--create)
   - Тіло:
     ```json
     {
       "amount": 90000, // в копійках (finalPrice * 100)
       "ccy": 980, // ISO 4217 код для UAH
       "merchantPaymInfo": {}, // Обов'язково для інтеграції з ПРРО
       "redirectUrl": "{frontendConfig.successUrl}?registrationId={id}",
       "successUrl": "{frontendConfig.successUrl}?registrationId={id}",
       "failUrl": "{frontendConfig.failureUrl}?registrationId={id}",
       "webHookUrl": "{webhookUrl}",
       "merchantData": {
         "registrationId": "{id}"
       }
     }
     ```

3. **Збереження посилання на оплату**
   - Збереження `plataMonoInvoiceId` з відповіді
   - Збереження `paymentLink` (pageUrl/invoiceUrl) з відповіді
   - Повернення посилання на оплату користувачу

### Оновлення статусу оплати

**Ендпоінт webhook**: `POST /api/webhooks/plata-mono`

**Валідація webhook**:

1. Перевірка підпису ECDSA за допомогою публічного ключа (якщо налаштовано `plataWebhookPublicKey`)
   - Заголовок: `X-Sign` (base64-кодований підпис ECDSA)
   - Алгоритм: ECDSA з SHA256
   - Публічний ключ: Base64-кодований, отримується з `/api/merchant/pubkey` або налаштовується в env
   - Документація: [Monobank Webhook Verification](https://monobank.ua/api-docs/acquiring/dev/webhooks/verify)
2. Валідація структури payload за допомогою схеми Zod
3. Витягнення `invoiceId` з payload

**Схема payload webhook**:

```typescript
{
  invoiceId: string;              // Обов'язково
  status?: 'created' | 'processing' | 'success' | 'failure' | 'expired' | 'hold';
  failureReason?: string;
  amount?: number;
  ccy?: number;
  finalAmount?: number;
  createdDate?: string;
  modifiedDate?: string;
  reference?: string;
  paymentId?: string;
  merchantData?: {
    registrationId?: string;
    customerName?: string;
    eventTitle?: string;
  };
  cancelList?: unknown[];
}
```

**Примітка**: Тільки `status === 'success'` запускає завершення оплати. Інші статуси (`created`, `processing`, `hold`) є проміжними станами.

**Процес успішної оплати**:

1. **Пошук оплати**
   - Пошук оплати за `plataMonoInvoiceId`
   - Якщо не знайдено, повертається 404

2. **Оновлення статусу оплати** (в межах транзакції)
   - Встановлення статусу оплати на `'completed'`
   - Збереження `plataMonoPaymentId`, якщо надано
   - Збереження `webhookData` для аудиту

3. **Оновлення реєстрації** (в межах тієї ж транзакції)
   - Встановлення статусу реєстрації на `'confirmed'`
   - Встановлення `paymentStatus` реєстрації на `'completed'`

4. **Оновлення події** (в межах тієї ж транзакції)
   - Збільшення `event.registeredCount` на 1
   - Використовує оператор `$inc` для атомарного збільшення

5. **Збільшення використання промокоду** (в межах тієї ж транзакції)
   - Якщо існує `registration.promoCodeId`
   - Атомарне збільшення `promoCode.usedCount` на 1
   - Використовує оператор `$inc`

6. **Відправка email підтвердження** (асинхронно, неблокуюче)
   - Відправка email підтвердження реєстрації
   - Включення деталей події та суми оплати

7. **Підтвердження транзакції**
   - Всі оновлення успішні або невдалі разом

**Процес невдалої оплати**:

1. **Оновлення статусу оплати** (в межах транзакції)
   - Встановлення статусу оплати на `'failed'`
   - Збереження `webhookData`

2. **Оновлення реєстрації** (в межах тієї ж транзакції)
   - Встановлення статусу реєстрації на `'pending'` (дозволяє повторну спробу)
   - Встановлення `paymentStatus` реєстрації на `'failed'`

3. **Відправка email про невдачу** (асинхронно, неблокуюче)
   - Відправка сповіщення про невдачу оплати
   - Включення посилання для повторної спроби

4. **Підтвердження транзакції**

**Важливо**: Місткість події НЕ збільшується при невдалій оплаті, дозволяючи користувачу повторити спробу оплати.

---

## Інтеграція промокодів

### Валідація промокоду

**Сервіс**: `PromoCodesService.validate()`

**Кроки валідації** (по порядку):

1. **Нормалізація коду**
   - Конвертація у великі літери
   - Обрізання пробілів

2. **Існування коду**
   - Пошук коду в базі даних
   - Якщо не знайдено → `ValidationError: "Invalid or expired promo code"`

3. **Активний статус**
   - Перевірка `isActive === true`
   - Якщо неактивний → `ValidationError: "Invalid or expired promo code"`

4. **Ліміт використання**
   - Перевірка `usedCount < usageLimit`
   - Якщо ліміт досягнуто → `ValidationError: "Promo code usage limit reached"`

5. **Дата закінчення**
   - Якщо `expirationDate` існує, перевірка, що вона в майбутньому
   - Якщо закінчився → `ValidationError: "Promo code has expired"`

6. **Відповідність події**
   - Якщо надані і `promoCode.eventId`, і параметр `eventId`:
     - Обидва мають бути валідними ObjectIds
     - Вони мають точно відповідати
   - Якщо `promoCode.eventId` існує, але не відповідає → `ValidationError: "Promo code is not valid for this event"`
   - Якщо `promoCode.eventId` null, код глобальний (дійсний для всіх подій)

**Повернення**: Валідований об'єкт `IPromoCode`

### Розрахунок ціни

**Утиліта**: `src/utils/pricing.util.ts`

**Функція**: `calculatePrice(basePrice: number, promoCode?: IPromoCode | null)`

**Логіка**:

1. **Без промокоду або неактивний**

   ```typescript
   return { finalPrice: basePrice, discountAmount: 0 };
   ```

2. **Відсоткова знижка**

   ```typescript
   discountAmount = (basePrice * discountValue) / 100;
   finalPrice = basePrice - discountAmount;
   ```

3. **Фіксована знижка**

   ```typescript
   discountAmount = discountValue;
   finalPrice = basePrice - discountAmount;
   ```

4. **Захист мінімальної ціни**
   ```typescript
   finalPrice = Math.max(0, finalPrice); // Ніколи не від'ємна
   ```

**Повернення**: `{ finalPrice: number, discountAmount: number }`

### Відстеження використання промокоду

**Коли збільшується використання**:

- Тільки після успішного завершення оплати
- В межах тієї ж транзакції бази даних, що й підтвердження оплати
- Атомарна операція з використанням оператора MongoDB `$inc`

**Метод сервісу**: `PromoCodesService.incrementUsage()`

```typescript
await PromoCode.updateOne({ _id: promoCodeId }, { $inc: { usedCount: 1 } }, { session });
```

**Важливо**: Використання НЕ збільшується під час:

- Валідації коду
- Створення реєстрації
- Створення оплати
- Невдалої оплати

---

## Повний процес від початку до кінця

### Сценарій: Користувач реєструється з промокодом

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Користувач надсилає реєстрацію                          │
│    POST /api/registrations                                  │
│    { eventId, name, surname, email, city, promoCode }      │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Валідація вхідних даних                                  │
│    - Присутні обов'язкові поля                              │
│    - Валідний формат email                                  │
│    - Валідний формат телефону (якщо надано)                │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Валідація події                                          │
│    - Подія існує                                            │
│    - Подія має вільні місця                                 │
│    - Немає дублікату реєстрації (за email)                 │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Валідація промокоду (якщо надано)                        │
│    - Код існує та активний                                  │
│    - Ліміт використання не досягнуто                        │
│    - Не закінчився                                          │
│    - Дійсний для цієї події (якщо специфічний для події)    │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Розрахунок ціни                                          │
│    - Отримання basePrice з події або конфігурації          │
│    - Застосування знижки промокоду                         │
│    - Розрахунок finalPrice                                  │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. Створення реєстрації та оплати (Транзакція)             │
│    - Створення реєстрації (статус: pending)                 │
│    - Створення оплати (статус: pending)                     │
│    - Виклик API Monobank для створення рахунку              │
│    - Зв'язування оплати з реєстрацією                       │
│    - Підтвердження транзакції                               │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. Повернення відповіді                                     │
│    - Деталі реєстрації                                      │
│    - Посилання на оплату                                    │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 8. Користувач завершує оплату                              │
│    - Перенаправлення на сторінку оплати Monobank           │
│    - Завершення оплати                                      │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 9. Monobank надсилає webhook                               │
│    POST /api/webhooks/plata-mono                           │
│    { invoiceId, status: 'success', paymentId }              │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 10. Обробка webhook (Транзакція)                           │
│     - Перевірка підпису webhook                            │
│     - Пошук оплати за invoiceId                             │
│     - Оновлення статусу оплати: completed                   │
│     - Оновлення статусу реєстрації: confirmed              │
│     - Оновлення paymentStatus реєстрації: completed        │
│     - Збільшення event.registeredCount                      │
│     - Збільшення promoCode.usedCount (якщо застосовно)      │
│     - Підтвердження транзакції                              │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│ 11. Відправка email підтвердження (Асинхронно)              │
│     - Реєстрація підтверджена                               │
│     - Деталі події                                          │
│     - Сума оплати                                           │
└─────────────────────────────────────────────────────────────┘
```

---

## Правила валідації

### Валідація реєстрації

**Обов'язкові поля публічної реєстрації**:

- `eventId`: Має бути валідним ObjectId або UUID
- `name`: 2-50 символів
- `surname`: 2-50 символів
- `email`: Валідний формат email, малі літери, унікальний для події
- `city`: 2-100 символів

**Опціональні поля публічної реєстрації**:

- `runningClub`: Макс 100 символів
- `phone`: Макс 20 символів, формат: `+?[\d\s-()]+`
- `promoCode`: Макс 50 символів (нормалізується у великі літери)

**Бізнес-правила**:

- Подія має існувати
- Подія має мати вільні місця
- Email має бути унікальним для події
- Дата події має бути в майбутньому (перевіряється при створенні події)

### Валідація оплати

**Створення оплати**:

- `amount` має бути >= 0
- `currency` за замовчуванням 'UAH'
- `registrationId` має посилатися на валідну реєстрацію

**Валідація webhook**:

- Перевірка підпису ECDSA за допомогою публічного ключа (якщо `plataWebhookPublicKey` налаштовано)
- Заголовок `X-Sign` містить base64-кодований підпис ECDSA
- Публічний ключ можна отримати з `GET /api/merchant/pubkey` або налаштувати в env
- `invoiceId` має бути присутнім
- `status` може бути: 'created', 'processing', 'success', 'failure', 'expired', 'hold'

### Валідація промокоду

Див. розділ [Валідація промокоду](#валідація-промокоду) вище.

**Додаткові правила**:

- Код нечутливий до регістру (нормалізується у великі літери)
- Код обрізається від пробілів
- Коди для конкретної події мають точно відповідати події
- Глобальні коди (без eventId) працюють для всіх подій

---

## Переходи станів

### Статус реєстрації

```
pending ──[оплата завершена]──► confirmed
  │
  └──[користувач скасовує]──► cancelled
```

**Стани**:

- `pending`: Початковий стан, очікування оплати
- `confirmed`: Оплата завершена, реєстрація активна
- `cancelled`: Користувач скасував реєстрацію

**Переходи**:

- `pending → confirmed`: Webhook оплати зі статусом 'success'
- `pending → cancelled`: Скасування ініційоване користувачем (тільки для автентифікованих)

### Статус оплати

```
pending ──[webhook: success]──► completed
  │
  └──[webhook: failure]──► failed
```

**Стани**:

- `pending`: Оплата створена, очікує завершення
- `completed`: Оплата успішно оброблена
- `failed`: Оплата невдала або відхилена
- `refunded`: Оплата повернена (майбутній стан)

**Переходи**:

- `pending → completed`: Webhook зі статусом 'success'
- `pending → failed`: Webhook зі статусом 'failure'

### Використання промокоду

```
unused ──[оплата завершена]──► used (usedCount++)
```

**Відстеження**:

- `usedCount` починається з 0
- Збільшується атомарно при завершенні оплати
- Не може перевищувати `usageLimit`

---

## Безпека транзакцій

### Критичні операції в транзакціях

Всі операції, що змінюють кілька документів, обгорнуті в транзакції MongoDB:

1. **Створення реєстрації**
   - Створення реєстрації
   - Створення оплати
   - Створення рахунку Plata (зовнішнє, але запис про оплату створюється в транзакції)

2. **Завершення оплати**
   - Оновлення статусу оплати
   - Оновлення статусу реєстрації
   - Збільшення місткості події
   - Збільшення використання промокоду

3. **Невдала оплата**
   - Оновлення статусу оплати
   - Оновлення статусу реєстрації

### Гарантії транзакцій

- **Атомарність**: Всі операції успішні або всі невдалі
- **Консистентність**: Стан бази даних залишається консистентним
- **Ізоляція**: Паралельні транзакції не заважають одна одній
- **Довговічність**: Підтверджені зміни постійні

### Запобігання гонкам

1. **Місткість події**
   - Використовує оператор MongoDB `$inc` (атомарний)
   - Перевіряється перед створенням реєстрації
   - Збільшується тільки при успішній оплаті

2. **Використання промокоду**
   - Використовує оператор MongoDB `$inc` (атомарний)
   - Валідується перед реєстрацією
   - Збільшується тільки при успішній оплаті

3. **Дублювання реєстрації**
   - Унікальні індекси запобігають дублюванню
   - Перевіряється в межах транзакції

---

## Обробка помилок

### Типи помилок

**ValidationError**:

- Невірні вхідні дані
- Порушення бізнес-правил
- Невдала валідація промокоду

**NotFoundError**:

- Подія не знайдена
- Реєстрація не знайдена
- Оплата не знайдена
- Промокод не знайдений

**ConflictError**:

- Подія заповнена
- Дублювання реєстрації
- Ціна події не налаштована
- Неможливо зареєструватися на минулу подію

**ForbiddenError**:

- Неавторизований доступ
- Не є організатором події

**AppError**:

- Невдачі зовнішніх API (Monobank)
- Помилки конфігурації

### Формат відповіді з помилкою

```json
{
  "success": false,
  "error": {
    "message": "Повідомлення про помилку",
    "errors": {
      "field": ["Повідомлення про помилку для поля"]
    }
  }
}
```

### Обробка помилок webhook

- Невірний підпис → 400 Bad Request
- Оплата не знайдена → 404 Not Found
- Помилка обробки → 500 Internal Server Error
- Завжди повертає 200 при отриманні webhook (щоб запобігти повторним спробам)

---

## API ендпоінти

### Ендпоінти реєстрації

**Публічна реєстрація**

- `POST /api/registrations`
- Автентифікація не потрібна
- Створює реєстрацію зі статусом pending з посиланням на оплату

**Автентифікована реєстрація**

- `POST /api/registrations` (з токеном автентифікації)
- Створює підтверджену реєстрацію негайно

**Отримати мої реєстрації**

- `GET /api/registrations/my`
- Потрібна автентифікація
- Повертає реєстрації користувача

**Скасувати реєстрацію**

- `DELETE /api/registrations/:id`
- Потрібна автентифікація
- Тільки для автентифікованих реєстрацій

### Ендпоінти оплати

**Обробник webhook**

- `POST /api/webhooks/plata-mono`
- Отримує оновлення статусу оплати від Monobank
- Валідує підпис та обробляє оплату

### Ендпоінти промокодів

**Валідувати промокод**

- `POST /api/promo-codes/validate`
- Обмеження швидкості: 10 запитів/хвилину
- Повертає деталі промокоду, якщо валідний

---

## Ключові файли реалізації

### Моделі

- `src/models/Registration.ts` - Схема реєстрації
- `src/models/Payment.ts` - Схема оплати
- `src/models/PromoCode.ts` - Схема промокоду

### Сервіси

- `src/services/registrations.service.ts` - Бізнес-логіка реєстрації
- `src/services/payments.service.ts` - Обробка оплати
- `src/services/promoCodes.service.ts` - Валідація промокоду

### Контролери

- `src/controllers/registrations.controller.ts` - Ендпоінти реєстрації
- `src/controllers/webhooks.controller.ts` - Обробник webhook оплати
- `src/controllers/promoCodes.controller.ts` - Ендпоінти промокодів

### Утиліти

- `src/utils/pricing.util.ts` - Логіка розрахунку ціни

### Валідатори

- `src/validators/registrations.validator.ts` - Валідація вхідних даних реєстрації
- `src/validators/webhooks.validator.ts` - Валідація payload webhook
- `src/validators/promoCodes.validator.ts` - Валідація вхідних даних промокоду

---

## Найкращі практики

1. **Завжди використовуйте транзакції** для операцій з кількома документами
2. **Валідуйте промокоди** перед створенням реєстрації
3. **Збільшуйте використання тільки** після успішної оплати
4. **Обробляйте невдачі webhook** коректно (логуйте, не падайте)
5. **Використовуйте атомарні операції** (`$inc`) для лічильників
6. **Перевіряйте місткість** перед дозволом реєстрації
7. **Запобігайте дублюванню** за допомогою унікальних індексів
8. **Зберігайте і рядок коду, і ID** для промокодів
9. **Відправляйте email асинхронно** щоб не блокувати
10. **Валідуйте підписи webhook** для безпеки

---

## Міркування безпеки

1. **Перевірка підпису webhook**: Валідація підпису ECDSA за допомогою публічного ключа від Monobank
2. **Обмеження швидкості**: Ендпоінт валідації промокоду обмежений за швидкістю
3. **Валідація вхідних даних**: Всі вхідні дані валідуються за допомогою схем Zod
4. **Безпека транзакцій**: Критичні операції використовують транзакції бази даних
5. **Унікальні обмеження**: Запобігають дублюванню реєстрацій
6. **Унікальність email**: Одна реєстрація на email для події

---

## Майбутні покращення

Потенційні покращення:

- Механізм повторної спроби оплати
- Обробка повернень
- Часткові оплати
- Вибір методу оплати
- Кілька промокодів на реєстрацію
- Промокоди для конкретного користувача
- Аналітика промокодів
- Опрос статусу оплати (резервний варіант для webhook)
- Адмін-панель для управління реєстраціями та оплатами
